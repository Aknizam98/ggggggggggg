import random
from os import system
from datetime import datetime

# Downloaded libraries - –°–∫–∞—á–µ–Ω–Ω—ã–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏
from aiogram import Bot
from aiogram.utils import executor
from aiogram.dispatcher import Dispatcher
from aiogram.types import *

# Created module - –°–æ–∑–¥–∞–Ω–Ω—ã–π –º–æ–¥—É–ª—å
from core.config import *
from core.button import *
from core.inline import *
from database.dbpars import *
from database.dbusers import check_users, registrstion_users, search_inline_mode

system("clear")
bot = Bot(token=TOKEN, parse_mode="HTML")
dp = Dispatcher(bot)


@dp.message_handler(commands=["start"])
async def start(message: Message):
    user_id = message.chat.id

    check = check_users(user_id)
    if check is None:
        await message.reply("–í—ã –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã", reply_markup=reg_markup)
    else:
        await message.reply("–ò–Ω—Ñ–æ –æ –±–æ—Ç–µ", reply_markup=auth_inline)
        await message.reply("–í—ã —É–∂–µ —É –Ω–∞—Å –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã, –ø–æ–ª—å–∑—É–π—Ç–µ—Å—å –Ω–∞ –∑–¥–æ—Ä–æ–≤—å–µ üòá", reply_markup=auth_markup)
        

@dp.message_handler(content_types=ContentTypes.CONTACT)
async def add_contact(message: Message):
    user_id = message.contact.user_id
    username = message.chat.username
    first_name = message.contact.first_name
    last_name = message.contact.last_name
    phone = message.contact.phone_number
    registrstion_users(user_id, username, first_name, last_name, phone)

    information = f"–ê–π–¥–∏: {user_id}\n–ü–æ–ª(–∫–æ–µ) –ò–º—è: @{username}\n–ò–º—è: {first_name}\n–§–∞–º–∏–ª–∏—è: {last_name}\n–ù–æ–º–µ—Ä: {phone}\n–í—Ä–µ–º—è –∑–∞–ø–∏—Å–∏: {datetime.now().strftime('%Y-%m-%d')}"
    await bot.send_message(chat_id=ADMIN_USERID, text=information)
    await message.reply(text="–í—ã –±—ã–ª–∏ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –≤ –Ω–∞—à–µ–º —Å–µ—Ä–≤–∏—Å–µ, –ø–æ–ª—å–∑—É–π—Ç–µ—Å—å –Ω–∞ –∑–¥–æ—Ä–æ–≤—å–µ üòá", reply_markup=auth_markup)


# 
@dp.inline_handler()
async def inline_query(inline_query: InlineQuery):
    text = inline_query.query
    results = search_inline_mode(text)

    articles = []
    for result in results:
        article = InlineQueryResultArticle(
            id = f"{result[0]}",
            title = f"{result[2]}",
            description = f"{result[3]}",
            url = f"{result[5]}",
            hide_url=True,
            input_message_content = InputTextMessageContent(
                message_text = f"\n<b>–ó–∞–≥–æ–ª–æ–≤–æ–∫:</b> <a href='{result[6]}'>{result[2]}</a>\n<b>–ö–æ—Ç–µ–≥–æ—Ä–∏—è:</b> {result[1]}\n<b>–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è:</b> {result[3]}\n<b>–î–∞—Ç–∞:</b> {result[4]}\n<b>–ü–æ–¥—Ä–æ–±–Ω–µ–µ:</b> <a href='{result[5]}'>–ù–∞–∂–º–∏—Ç–µ —Ç—É—Ç</a>"
            )
        )
        articles.append(article)
        if len(articles) == 50:
            break
    
    await inline_query.answer(articles, cache_time=1, is_personal=True)


@dp.message_handler(content_types=ContentTypes.TEXT)
async def message_text_user(message: Message):
    user_id = message.chat.id
    check = check_users(user_id)
    if check is None:
        await message.answer("–°–Ω–∞—á–∞–ª–æ –ø—Ä–æ–π–¥–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é")
    else:
        if message.text.lower() == "–º–µ–Ω—é":
            await message.answer("–í—ã –≤ –º–µ–Ω—é", reply_markup=auth_markup)
            await message.delete()
        elif message.text.lower() == "–∫–∞—Ç–µ–≥–æ—Ä–∏–∏":
            category_db = ReplyKeyboardMarkup(resize_keyboard=True)
            for cotegory in get_cotegory_events():
                category_db.add(KeyboardButton(text=cotegory))
            category_db.add(KeyboardButton(text="–ú–µ–Ω—é"))
            await message.answer("–í—ã –≤ –∫–∞—Ç–∏–≥–æ—Ä–∏–∏", reply_markup=category_db)

        elif message.text in get_cotegory_events():
            values_category_db = ReplyKeyboardMarkup(resize_keyboard=True, row_width=1)
            for values_category in get_values_category_events(message.text):
                values_category_db.add(KeyboardButton(text=values_category))
            values_category_db.add(KeyboardButton(text="–ú–µ–Ω—é"))
            await message.answer(f"–í—ã –≤ —Ä–∞–∑–¥–µ–ª–µ: {message.text}", reply_markup=values_category_db)

        elif message.text in check_title():
            text = get_title_category_events(message.text)
            await message.reply(text)

        
@dp.callback_query_handler(text_contains="menu_")
async def menu_callback(call: CallbackQuery):
    if call.data and call.data.startswith("menu_"):
        code = call.data[-1:]
        if code.isdigit():
            code = int(code)
        if code == 1:
            location_inline.inline_keyboard = []
            num = 0
            for location in get_location():
                location_inline.add(
                    InlineKeyboardButton(text=location[1], callback_data=f"mesta_{num}")
                )
                num += 1
            location_inline.add(InlineKeyboardButton(text="–ú–µ–Ω—é", callback_data="menu"))
            await call.message.edit_reply_markup(reply_markup=location_inline)
        if code == 2:
            pass
        if code == 3:
            pass


if __name__ == '__main__':
    try:
        executor.start_polling(dp, skip_updates=True)
    except (KeyboardInterrupt, SystemExit):
        pass